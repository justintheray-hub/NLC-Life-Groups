# sync_groups.py
import os
import base64
import requests
from typing import List, Dict, Any
from supabase import create_client  # pip install supabase requests

PCO_APP_ID = os.environ["c595bc98a31668bdbfb9a16d2466be1fda0cb417f8d56f32f6e6af8ec5540e6f"]
PCO_SECRET = os.environ["pco_pat_b4d76c2a27b85ab778d433729ed4470ceac85aeedd573ec630eba14129d9790abb1f4e09"]
SUPABASE_URL = os.environ["https://rvfbwjvrrwwnofbghdpk.supabase.co"]
SUPABASE_SERVICE_KEY = os.environ["process.env.SUPABASE_KEY"]  # service role key

supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)

BASE_URL = "https://api.planningcenteronline.com/groups/v2/groups"


def basic_auth_header(app_id: str, secret: str) -> str:
    token = base64.b64encode(f"{app_id}:{secret}".encode("utf-8")).decode("utf-8")
    return f"Basic {token}"


def fetch_all_groups() -> Dict[str, Any]:
    """Fetch all groups with tags, handling pagination."""
    headers = {
        "Authorization": basic_auth_header(PCO_APP_ID, PCO_SECRET),
        "Content-Type": "application/json",
    }

    url = f"{BASE_URL}?include=tags&per_page=100"
    all_data: List[Dict[str, Any]] = []
    included: List[Dict[str, Any]] = []

    while url:
        resp = requests.get(url, headers=headers)
        resp.raise_for_status()
        json_data = resp.json()
        all_data.extend(json_data.get("data", []))
        included.extend(json_data.get("included", []))
        links = json_data.get("links", {})
        url = links.get("next")  # JSON:API pagination

    return {"data": all_data, "included": included}


def build_tag_lookup(included):
    """Build a map of tag id -> tag name from included resources."""
    tag_lookup = {}
    for item in included:
        if item.get("type") == "Tag":
            tag_lookup[item["id"]] = item["attributes"]["name"]
    return tag_lookup


def parse_tags_for_group(group: Dict[str, Any], tag_lookup: Dict[str, str]):
    rel = group.get("relationships", {})
    tags_rel = rel.get("tags", {}).get("data", [])
    names = [tag_lookup.get(t["id"]) for t in tags_rel if tag_lookup.get(t["id"])]

    campus = None
    stage_of_life = None
    group_type = None
    days_of_week = []

    # CONVENTION (you can change this):
    # "Campus: Conway", "Stage: Young Adults", "Type: Bible Study", "Day: Monday"
    for name in names:
        if name.startswith("Campus:"):
            campus = name.split(":", 1)[1].strip()
        elif name.startswith("Stage:"):
            stage_of_life = name.split(":", 1)[1].strip()
        elif name.startswith("Type:"):
            group_type = name.split(":", 1)[1].strip()
        elif name.startswith("Day:"):
            day = name.split(":", 1)[1].strip()
            days_of_week.append(day)

    return {
        "campus": campus,
        "stage_of_life": stage_of_life,
        "group_type": group_type,
        "days_of_week": days_of_week,
        "tag_names": names,
    }


def transform_group(group: Dict[str, Any], tag_lookup: Dict[str, str]) -> Dict[str, Any]:
    attrs = group.get("attributes", {})
    tag_info = parse_tags_for_group(group, tag_lookup)

    return {
        "pco_group_id": group["id"],
        "name": attrs.get("name"),
        "description": attrs.get("description"),
        "campus": tag_info["campus"],
        "days_of_week": tag_info["days_of_week"] or None,
        "time_of_day": attrs.get("meeting_time"),
        "stage_of_life": tag_info["stage_of_life"],
        "group_type": tag_info["group_type"],
        "is_open": not attrs.get("archived_at"),  # basic example
        "max_size": attrs.get("capacity"),
        "current_size": attrs.get("enrollment"),
        "church_center_url": attrs.get("url"),  # adjust per actual API
        "tags": tag_info["tag_names"],
    }


def sync():
    print("Fetching groups from Planning Center...")
    raw = fetch_all_groups()
    tag_lookup = build_tag_lookup(raw["included"])

    rows = [transform_group(g, tag_lookup) for g in raw["data"]]

    print(f"Upserting {len(rows)} groups into Supabase...")
    # upsert on pco_group_id
    response = (
        supabase.table("groups")
        .upsert(rows, on_conflict="pco_group_id")  # requires unique constraint
        .execute()
    )
    print("Done, Supabase response:", response)


if __name__ == "__main__":
    sync()
alter table public.groups
  add constraint groups_pco_group_id_key unique (pco_group_id);
